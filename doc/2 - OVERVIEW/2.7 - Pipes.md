## Pipes

管道是用 @Injectable() 装饰器注释的类。 管道应该实现 PipeTransform 接口。

![img](https://docs.nestjs.com/assets/Pipe_1.png)

管道有两个典型的用例：

转换：将输入数据转换为所需的形式（例如，从字符串到整数）
验证：评估输入数据，如果有效，只需不变地通过； 否则，当数据不正确时抛出异常
在这两种情况下，管道都会对控制器路由处理程序正在处理的参数进行操作。 Nest 在调用方法之前插入一个管道，管道接收指定给该方法的参数并对其进行操作。 任何转换或验证操作都发生在那个时候，之后路由处理程序将使用任何（可能）转换的参数调用。

Nest 带有许多内置管道，您可以开箱即用。 您还可以构建自己的自定义管道。 在本章中，我们将介绍内置管道并展示如何将它们绑定到路由处理程序。 然后，我们将检查几个定制的管道，以展示如何从头开始构建一个管道。

> 贴士
>
> 管道运行在异常区域内。 这意味着当管道抛出异常时，它由异常层处理（全局异常过滤器和任何应用于当前上下文的异常过滤器）。 综上所述，应该清楚的是，当 Pipe 中抛出异常时，后续不会执行任何控制器方法。 这为您提供了一种最佳实践技术，用于验证从系统边界的外部来源进入应用程序的数据。

### 内置管道

Nest 随附 8 个开箱即用的管道：

- `ValidationPipe`
- `ParseIntPipe`
- `ParseFloatPipe`
- `ParseBoolPipe`
- `ParseArrayPipe`
- `ParseUUIDPipe`
- `ParseEnumPipe`
- `DefaultValuePipe`

它们是从 @nestjs/common 包中导出的。

让我们快速了解一下 ParseIntPipe 的使用。 这是转换用例的一个示例，其中管道确保将方法处理程序参数转换为 JavaScript 整数（如果转换失败则抛出异常）。 在本章的后面，我们将展示 ParseIntPipe 的一个简单的自定义实现。 下面的示例技术也适用于其他内置转换管道（ParseBoolPipe、ParseFloatPipe、ParseEnumPipe、ParseArrayPipe 和 ParseUUIDPipe，我们将在本章中将其称为 Parse* 管道）。

### 绑定管道

要使用管道，我们需要将管道类的实例绑定到适当的上下文。 在我们的 ParseIntPipe 示例中，我们希望将管道与特定的路由处理程序方法相关联，并确保它在调用该方法之前运行。 我们使用以下构造来实现，我们将其称为在方法参数级别绑定管道：

```typescript
@Get(':id')
async findOne(@Param('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

这确保了以下两个条件之一为真：要么我们在 findOne() 方法中收到的参数是一个数字（如我们对 this.catsService.findOne() 的调用所预期的那样），要么在路由之前抛出异常 处理程序被调用。

例如，假设路由被称为：

```
GET localhost:3000/abc
```

Nest 会抛出这样的异常：

```
{
  "statusCode": 400,
  "message": "Validation failed (numeric string is expected)",
  "error": "Bad Request"
}
```

该异常将阻止 findOne() 方法的主体执行。

在上面的例子中，我们传递了一个类 (ParseIntPipe)，而不是一个实例，将实例化的责任留给框架并启用依赖注入。 与管道和守卫一样，我们可以改为传递一个就地实例。 如果我们想通过传递选项来自定义内置管道的行为，则传递就地实例很有用：

```typescript
@Get(':id')
async findOne(
  @Param('id', new ParseIntPipe({ errorHttpStatusCode: HttpStatus.NOT_ACCEPTABLE }))
  id: number,
) {
  return this.catsService.findOne(id);
}
```

绑定其他转换管道（所有 Parse* 管道）的工作方式类似。 这些管道都在验证路由参数、查询字符串参数和请求正文值的上下文中工作。

例如使用查询字符串参数：

```typescript
@Get()
async findOne(@Query('id', ParseIntPipe) id: number) {
  return this.catsService.findOne(id);
}
```

这是使用 ParseUUIDPipe 解析字符串参数并验证它是否为 UUID 的示例。

```typescript
@Get(':uuid')
async findOne(@Param('uuid', new ParseUUIDPipe()) uuid: string) {
  return this.catsService.findOne(uuid);
}
```

> 贴士
>
> 使用 ParseUUIDPipe() 时，您正在解析版本 3、4 或 5 中的 UUID，如果您只需要特定版本的 UUID，您可以在管道选项中传递一个版本。

上面我们已经看到了绑定各种 Parse* 系列内置管道的示例。 绑定验证管道有点不同； 我们将在下一节中讨论。

> 贴士
>
> 此外，有关验证管道的大量示例，请参阅验证技术。

### 自定义管道

如前所述，您可以构建自己的自定义管道。 虽然 Nest 提供了强大的内置 ParseIntPipe 和 ValidationPipe，但让我们从头开始构建每个的简单自定义版本，看看如何构建自定义管道。

我们从一个简单的 ValidationPipe 开始。 最初，我们将让它简单地接受一个输入值并立即返回相同的值，表现得像一个恒等函数。

```typescript
// validation.pipe.ts
import { PipeTransform, Injectable, ArgumentMetadata } from '@nestjs/common';

@Injectable()
export class ValidationPipe implements PipeTransform {
  transform(value: any, metadata: ArgumentMetadata) {
    return value;
  }
}
```

> 贴士
>
> PipeTransform<T, R> 是任何管道都必须实现的通用接口。 泛型接口使用 T 表示输入值的类型，使用 R 表示 transform() 方法的返回类型。

每个管道都必须实现 transform() 方法来实现 PipeTransform 接口契约。 这个方法有两个参数：

* 价值
* 元数据

value 参数是当前处理的方法参数（在它被路由处理方法接收之前），而 metadata 是当前处理的方法参数的元数据。 元数据对象具有以下属性：

```typescript
export interface ArgumentMetadata {
  type: 'body' | 'query' | 'param' | 'custom';
  metatype?: Type<unknown>;
  data?: string;
}
```

这些属性描述当前处理的参数。

|          |                                                              |
| -------- | ------------------------------------------------------------ |
| type     | 表示参数是正文@Body()、查询@Query()、参数@Param() 还是自定义参数（在此处阅读更多信息）。 |
| metatype | 提供参数的元类型，例如 String。 注意：如果您在路由处理程序方法签名中省略类型声明，或者使用 vanilla JavaScript，则该值是未定义的。 |
| data     | 传递给装饰器的字符串，例如@Body('string')。 如果将装饰器括号留空，则未定义。 |

> 警告
>
> TypeScript 接口在转译过程中消失。 因此，如果将方法参数的类型声明为接口而不是类，则元类型值将是 Object。

### 基于模式的验证

让我们使验证管道更有用一点。 仔细查看 Cats Controller 的 create() 方法，我们可能希望在尝试运行我们的服务方法之前确保 post body 对象有效。

```typescript
@Post()
async create(@Body() createCatDto: CreateCatDto) {
  this.catsService.create(createCatDto);
}
```

让我们关注 createCatDto body 参数。 它的类型是 CreateCatDto：

```typescript
// create-cat.dto.ts
export class CreateCatDto {
  name: string;
  age: number;
  breed: string;
}
```

